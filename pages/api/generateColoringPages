// pages/api/generateColoringPages.js

export default function handler(req, res) {
  // 이 API는 POST만 허용합니다.
  if (req.method !== "POST") {
    res.setHeader("Allow", ["POST"]);
    return res
      .status(405)
      .json({ error: "Method Not Allowed. Use POST with { story }." });
  }

  try {
    const { story } = req.body || {};

    if (!story || typeof story !== "string") {
      return res.status(400).json({ error: "Missing or invalid `story`." });
    }

    // 스토리를 문장/문단 단위로 잘라서 4~8페이지 정도로 분할
    const maxPages = 8;
    const targetCharsPerPage = Math.max(300, Math.floor(story.length / 6));

    const rawSegments = story
      .split(/\n{2,}|\r\n{2,}/) // 빈 줄 기준 1차 분할
      .flatMap((seg) => seg.split(/(?<=[.!?。！？])\s+/)); // 문장 기준 2차 분할

    const pages = [];
    let current = "";

    for (const seg of rawSegments) {
      const trimmed = seg.trim();
      if (!trimmed) continue;

      if (current.length + trimmed.length + 1 > targetCharsPerPage) {
        if (current) {
          pages.push(current.trim());
          current = "";
        }
      }
      current += (current ? " " : "") + trimmed;

      if (pages.length >= maxPages) break;
    }
    if (current && pages.length < maxPages) {
      pages.push(current.trim());
    }

    // 최소 1장은 보장
    if (pages.length === 0) {
      pages.push(story.slice(0, targetCharsPerPage));
    }

    const result = pages.map((text, idx) => ({
      id: idx + 1,
      title: `Page ${idx + 1}`,
      text,
    }));

    return res.status(200).json({ pages: result });
  } catch (err) {
    console.error("generateColoringPages error:", err);
    return res.status(500).json({ error: "Internal server error" });
  }
}
